{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"go-collab-editor","text":"<p>A real-time collaborative text editor built with Go and the Jupiter OT (Operational Transformation) algorithm. Multiple users edit the same document simultaneously with automatic conflict resolution.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Real-time collaboration \u2014 multiple users edit the same document simultaneously via WebSocket</li> <li>OT conflict resolution \u2014 concurrent edits are automatically merged using the Jupiter algorithm</li> <li>Pluggable architecture \u2014 swap OT engines or storage backends via clean interfaces</li> <li>Lightweight frontend \u2014 vanilla JavaScript with CodeMirror 5, no build step required</li> <li>Presence awareness \u2014 see who's connected with colored user indicators</li> </ul>"},{"location":"#quick-links","title":"Quick links","text":"<ul> <li>Getting Started \u2014 clone, run, and try collaboration in under a minute</li> <li>Architecture \u2014 package graph, data flow, and design decisions</li> <li>OT Algorithm \u2014 deep dive into the retain/insert/delete operation model</li> <li>WebSocket Protocol \u2014 full protocol reference for building clients</li> <li>API Reference \u2014 auto-generated Go package documentation</li> </ul>"},{"location":"#tech-stack","title":"Tech stack","text":"Component Technology Backend Go stdlib <code>net/http</code> + gorilla/websocket OT algorithm Jupiter (retain/insert/delete model) Frontend Vanilla JS + CodeMirror 5 Persistence In-memory (pluggable <code>DocumentStore</code> interface)"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#development-setup","title":"Development setup","text":"<pre><code>git clone https://github.com/alimasry/go-collab-editor.git\ncd go-collab-editor\ngo run main.go\n</code></pre> <p>Open http://localhost:8080 to verify the server works.</p>"},{"location":"contributing/#testing","title":"Testing","text":"<p>Always run tests after modifying code:</p> <pre><code># All tests\ngo test ./...\n\n# Single package\ngo test -v ./ot\n\n# Single test\ngo test -v ./ot -run TestTransform_InsertDelete\n</code></pre>"},{"location":"contributing/#firestore-emulator-tests","title":"Firestore emulator tests","text":"<p>Firestore tests skip by default. To run them locally with the emulator:</p> <pre><code># Start the Firestore emulator (requires gcloud CLI)\ngcloud emulators firestore start --host-port=localhost:8081\n\n# In another terminal, run tests against the emulator\nexport FIRESTORE_EMULATOR_HOST=localhost:8081\nexport FIRESTORE_PROJECT=test\ngo test -v ./store\n</code></pre>"},{"location":"contributing/#code-organization","title":"Code organization","text":"Package Responsibility <code>ot/</code> Pure OT algorithm \u2014 zero external dependencies <code>server/</code> HTTP/WebSocket transport, hub, sessions, clients <code>store/</code> Document persistence abstraction <code>static/</code> Frontend (vanilla JS + CodeMirror 5)"},{"location":"contributing/#extending-the-system","title":"Extending the system","text":""},{"location":"contributing/#adding-a-new-ot-engine","title":"Adding a new OT engine","text":"<p>Implement the <code>Engine</code> interface in <code>ot/engine.go</code>:</p> <pre><code>type Engine interface {\n    TransformIncoming(op Operation, revision int, history []Operation) (Operation, error)\n}\n</code></pre> <p>Then pass your engine to <code>server.NewHub()</code> in <code>main.go</code>.</p>"},{"location":"contributing/#adding-a-new-storage-backend","title":"Adding a new storage backend","text":"<p>Implement the <code>DocumentStore</code> interface in <code>store/store.go</code>:</p> <pre><code>type DocumentStore interface {\n    Create(ctx context.Context, id, content string) error\n    Get(ctx context.Context, id string) (*DocumentInfo, error)\n    List(ctx context.Context) ([]DocumentInfo, error)\n    UpdateContent(ctx context.Context, id, content string, version int) error\n    AppendOperation(ctx context.Context, id string, op ot.Operation, version int) error\n    GetOperations(ctx context.Context, id string, fromVersion int) ([]ot.Operation, error)\n}\n</code></pre> <p>All methods take <code>context.Context</code> \u2014 this maps directly to Firestore, PostgreSQL, or other async backends.</p>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>To work on the docs site:</p> <pre><code># Install tooling (first time)\nmake docs-setup\n\n# Live preview at http://localhost:8000\nmake docs-serve\n\n# Build and check for broken links\nmake docs-build\n\n# Regenerate API reference after changing Go code\nmake docs-api\n</code></pre>"},{"location":"contributing/#commit-conventions","title":"Commit conventions","text":"<ul> <li>Commit early and often</li> <li>Keep commits focused on a single change</li> </ul>"},{"location":"deployment/","title":"Deployment","text":"<p>Deploy the collaborative editor on Google Cloud Run with Firestore persistence.</p>"},{"location":"deployment/#prerequisites","title":"Prerequisites","text":"<ul> <li>Google Cloud CLI installed</li> <li>Authenticated: <code>gcloud auth login</code></li> <li>A GCP project with billing enabled</li> </ul> <p>Set your project:</p> <pre><code>gcloud config set project YOUR_PROJECT_ID\n</code></pre>"},{"location":"deployment/#first-time-setup","title":"First-time setup","text":"<p>Enable the required APIs and create the Firestore database:</p> <pre><code>make gcp-setup\n</code></pre> <p>This enables Firestore, Cloud Run, and Cloud Build APIs, and creates a Firestore database in multi-region US (<code>nam5</code>).</p>"},{"location":"deployment/#deploy","title":"Deploy","text":"<pre><code>make gcp-deploy\n</code></pre> <p>This builds the Docker image via Cloud Build and deploys to Cloud Run. The service URL is printed when the deploy completes.</p> <p>To use a different project or region:</p> <pre><code>make gcp-deploy GCP_PROJECT=my-project GCP_REGION=europe-west1\n</code></pre>"},{"location":"deployment/#updating","title":"Updating","text":"<p>After code changes, redeploy with the same command:</p> <pre><code>make gcp-deploy\n</code></pre> <p>The env vars and args from the previous deployment are preserved.</p>"},{"location":"deployment/#authentication","title":"Authentication","text":"<p>Cloud Run uses Application Default Credentials. The default Compute Engine service account automatically has Firestore access \u2014 no service account key files needed.</p> <p>If you've restricted IAM permissions, ensure the Cloud Run service account has the Cloud Datastore User role:</p> <pre><code>gcloud projects add-iam-policy-binding YOUR_PROJECT_ID \\\n  --member=\"serviceAccount:$(gcloud iam service-accounts list --format='value(email)' --filter='displayName:Compute Engine')\" \\\n  --role=\"roles/datastore.user\"\n</code></pre>"},{"location":"deployment/#free-tier-limits","title":"Free tier limits","text":"Resource Free tier Cloud Run 2M requests/month, 360K vCPU-seconds, 180K GiB-seconds Firestore 1 GB storage, 50K reads/day, 20K writes/day Cloud Build 120 build-minutes/day"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.25 or later</li> <li>A web browser</li> </ul>"},{"location":"getting-started/#clone-and-run","title":"Clone and run","text":"<pre><code>git clone https://github.com/alimasry/go-collab-editor.git\ncd go-collab-editor\ngo run main.go\n</code></pre> <p>The server starts on http://localhost:8080.</p> <p>To use a custom port:</p> <pre><code>go run main.go -addr :3000\n</code></pre>"},{"location":"getting-started/#try-collaboration","title":"Try collaboration","text":"<ol> <li>Open http://localhost:8080 in your browser</li> <li>Note the URL hash (e.g. <code>#abc123</code>) \u2014 this identifies the document</li> <li>Open the same URL in a second browser tab</li> <li>Type in both tabs and watch edits appear in real-time</li> </ol> <p>Share the URL with others to collaborate on the same document.</p>"},{"location":"getting-started/#run-tests","title":"Run tests","text":"<pre><code># Run all tests\ngo test ./...\n\n# Run a specific package\ngo test -v ./ot\n\n# Run a single test\ngo test -v ./ot -run TestTransform_InsertDelete\n</code></pre>"},{"location":"getting-started/#project-structure","title":"Project structure","text":"Directory Purpose <code>ot/</code> Pure OT algorithm library (zero external dependencies) <code>server/</code> HTTP handler, WebSocket hub, sessions, and client management <code>store/</code> Document persistence (<code>MemoryStore</code>, <code>FirestoreStore</code>, and <code>CachedStore</code> implementations) <code>static/</code> Frontend: HTML, CSS, and JavaScript (CodeMirror 5) <code>main.go</code> Server entry point \u2014 wires everything together"},{"location":"getting-started/#deploy-to-cloud-run","title":"Deploy to Cloud Run","text":"<p>Build and deploy with Firestore as the storage backend:</p> <pre><code># Build the container image\ndocker build -t go-collab-editor .\n\n# Run locally with Firestore\ndocker run -p 8080:8080 \\\n  -e GCP_PROJECT=your-project-id \\\n  go-collab-editor -store firestore\n\n# Deploy to Cloud Run\ngcloud run deploy go-collab-editor \\\n  --source . \\\n  --set-env-vars GCP_PROJECT=your-project-id \\\n  --args=\"-store=firestore\"\n</code></pre> <p>The server reads the <code>PORT</code> environment variable automatically (set by Cloud Run).</p>"},{"location":"getting-started/#storage-backends","title":"Storage backends","text":"Flag Description <code>-store memory</code> In-memory (default) \u2014 data lost on restart <code>-store firestore</code> Google Cloud Firestore with write-behind cache \u2014 persistent across restarts <p>When using Firestore, set the project ID via <code>-project</code> flag or <code>GCP_PROJECT</code> env var.</p>"},{"location":"api/ot/","title":"ot","text":""},{"location":"api/ot/#ot","title":"ot","text":"<pre><code>import \"github.com/alimasry/go-collab-editor/ot\"\n</code></pre>"},{"location":"api/ot/#index","title":"Index","text":"<ul> <li>func Apply(doc string, op Operation) (string, error)</li> <li>type Component</li> <li>func (c Component) IsDelete() bool</li> <li>func (c Component) IsInsert() bool</li> <li>func (c Component) IsRetain() bool</li> <li>type Document</li> <li>func NewDocument(content string) *Document</li> <li>func (d *Document) Apply(op Operation) error</li> <li>type Engine</li> <li>type JupiterEngine</li> <li>func (e *JupiterEngine) TransformIncoming(op Operation, revision int, history []Operation) (Operation, error)</li> <li>type Operation</li> <li>func NewDelete(pos, count, docLen int) Operation</li> <li>func NewInsert(pos int, text string, docLen int) Operation</li> <li>func Transform(a, b Operation) (aPrime, bPrime Operation, err error)</li> <li>func (op Operation) BaseLen() int</li> <li>func (op Operation) IsNoop() bool</li> <li>func (op Operation) TargetLen() int</li> </ul>"},{"location":"api/ot/#func-apply","title":"func Apply","text":"<pre><code>func Apply(doc string, op Operation) (string, error)\n</code></pre> <p>Apply applies the operation to a document string.</p> <p></p>"},{"location":"api/ot/#type-component","title":"type Component","text":"<p>Component is a single step in an OT operation. Exactly one field should be set.</p> <pre><code>type Component struct {\n    Retain int    `json:\"retain,omitempty\"` // keep N chars unchanged\n    Insert string `json:\"insert,omitempty\"` // insert text at cursor\n    Delete int    `json:\"delete,omitempty\"` // remove N chars at cursor\n}\n</code></pre> <p></p>"},{"location":"api/ot/#func-component-isdelete","title":"func (Component) IsDelete","text":"<pre><code>func (c Component) IsDelete() bool\n</code></pre>"},{"location":"api/ot/#func-component-isinsert","title":"func (Component) IsInsert","text":"<pre><code>func (c Component) IsInsert() bool\n</code></pre>"},{"location":"api/ot/#func-component-isretain","title":"func (Component) IsRetain","text":"<pre><code>func (c Component) IsRetain() bool\n</code></pre>"},{"location":"api/ot/#type-document","title":"type Document","text":"<p>Document represents a collaborative document with its full operation history.</p> <pre><code>type Document struct {\n    Content string\n    Version int\n    History []Operation\n}\n</code></pre> <p></p>"},{"location":"api/ot/#func-newdocument","title":"func NewDocument","text":"<pre><code>func NewDocument(content string) *Document\n</code></pre> <p>NewDocument creates a new document with the given initial content.</p> <p></p>"},{"location":"api/ot/#func-document-apply","title":"func (*Document) Apply","text":"<pre><code>func (d *Document) Apply(op Operation) error\n</code></pre> <p>Apply applies an operation to the document, appending it to history.</p> <p></p>"},{"location":"api/ot/#type-engine","title":"type Engine","text":"<p>Engine abstracts the OT collaboration algorithm. Different algorithms (Jupiter, Wave, etc.) implement this interface.</p> <pre><code>type Engine interface {\n    // TransformIncoming transforms a client operation (created at the given\n    // revision) against all operations in the history since that revision.\n    // Returns the operation transformed to apply at the current server state.\n    TransformIncoming(op Operation, revision int, history []Operation) (Operation, error)\n}\n</code></pre> <p></p>"},{"location":"api/ot/#type-jupiterengine","title":"type JupiterEngine","text":"<p>JupiterEngine implements the Jupiter OT algorithm. It sequentially transforms the incoming operation against each server operation the client hasn't seen.</p> <pre><code>type JupiterEngine struct{}\n</code></pre> <p></p>"},{"location":"api/ot/#func-jupiterengine-transformincoming","title":"func (*JupiterEngine) TransformIncoming","text":"<pre><code>func (e *JupiterEngine) TransformIncoming(op Operation, revision int, history []Operation) (Operation, error)\n</code></pre>"},{"location":"api/ot/#type-operation","title":"type Operation","text":"<p>Operation is a sequence of components that transforms a document. Components are applied left-to-right, advancing a cursor through the input.</p> <pre><code>type Operation struct {\n    Ops []Component `json:\"ops\"`\n}\n</code></pre> <p></p>"},{"location":"api/ot/#func-newdelete","title":"func NewDelete","text":"<pre><code>func NewDelete(pos, count, docLen int) Operation\n</code></pre> <p>NewDelete creates an operation that deletes count chars at pos in a document of docLen.</p> <p></p>"},{"location":"api/ot/#func-newinsert","title":"func NewInsert","text":"<pre><code>func NewInsert(pos int, text string, docLen int) Operation\n</code></pre> <p>NewInsert creates an operation that inserts text at pos in a document of docLen.</p> <p></p>"},{"location":"api/ot/#func-transform","title":"func Transform","text":"<pre><code>func Transform(a, b Operation) (aPrime, bPrime Operation, err error)\n</code></pre> <p>Transform takes two concurrent operations a and b (both applied to the same document state) and returns aPrime and bPrime such that:</p> <pre><code>Apply(Apply(doc, a), bPrime) == Apply(Apply(doc, b), aPrime)\n</code></pre> <p></p>"},{"location":"api/ot/#func-operation-baselen","title":"func (Operation) BaseLen","text":"<pre><code>func (op Operation) BaseLen() int\n</code></pre> <p>BaseLen returns the expected input document length.</p> <p></p>"},{"location":"api/ot/#func-operation-isnoop","title":"func (Operation) IsNoop","text":"<pre><code>func (op Operation) IsNoop() bool\n</code></pre> <p>IsNoop returns true if the operation makes no changes.</p> <p></p>"},{"location":"api/ot/#func-operation-targetlen","title":"func (Operation) TargetLen","text":"<pre><code>func (op Operation) TargetLen() int\n</code></pre> <p>TargetLen returns the document length after the operation is applied.</p> <p>Generated by gomarkdoc</p>"},{"location":"api/server/","title":"server","text":""},{"location":"api/server/#server","title":"server","text":"<pre><code>import \"github.com/alimasry/go-collab-editor/server\"\n</code></pre>"},{"location":"api/server/#index","title":"Index","text":"<ul> <li>Constants</li> <li>func NewHandler(hub *Hub) http.Handler</li> <li>type Client</li> <li>func (c *Client) Info() ClientInfo</li> <li>func (c *Client) ReadPump()</li> <li>func (c *Client) WritePump()</li> <li>type ClientInfo</li> <li>type ClientMessage</li> <li>type Hub</li> <li>func NewHub(st store.DocumentStore, engine ot.Engine) *Hub</li> <li>func (h *Hub) GetSession(docID string) *Session</li> <li>func (h *Hub) Run()</li> <li>type ServerMessage</li> <li>func (m ServerMessage) Encode() []byte</li> <li>type Session</li> <li>func (s *Session) Run()</li> </ul>"},{"location":"api/server/#constants","title":"Constants","text":"<p>Message types exchanged over WebSocket.</p> <pre><code>const (\n    MsgJoin  = \"join\"\n    MsgLeave = \"leave\"\n    MsgOp    = \"op\"\n    MsgAck   = \"ack\"\n    MsgDoc   = \"doc\"\n    MsgError = \"error\"\n)\n</code></pre> <p></p>"},{"location":"api/server/#func-newhandler","title":"func NewHandler","text":"<pre><code>func NewHandler(hub *Hub) http.Handler\n</code></pre> <p>NewHandler creates the HTTP handler with all routes.</p> <p></p>"},{"location":"api/server/#type-client","title":"type Client","text":"<p>Client represents a single WebSocket connection.</p> <pre><code>type Client struct {\n    ID    string\n    Name  string\n    Color string\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/server/#func-client-info","title":"func (*Client) Info","text":"<pre><code>func (c *Client) Info() ClientInfo\n</code></pre>"},{"location":"api/server/#func-client-readpump","title":"func (*Client) ReadPump","text":"<pre><code>func (c *Client) ReadPump()\n</code></pre> <p>ReadPump reads messages from the WebSocket and routes them.</p> <p></p>"},{"location":"api/server/#func-client-writepump","title":"func (*Client) WritePump","text":"<pre><code>func (c *Client) WritePump()\n</code></pre> <p>WritePump writes messages from the send channel to the WebSocket.</p> <p></p>"},{"location":"api/server/#type-clientinfo","title":"type ClientInfo","text":"<p>ClientInfo describes a connected user.</p> <pre><code>type ClientInfo struct {\n    ID    string `json:\"id\"`\n    Name  string `json:\"name\"`\n    Color string `json:\"color\"`\n}\n</code></pre> <p></p>"},{"location":"api/server/#type-clientmessage","title":"type ClientMessage","text":"<p>ClientMessage is a message from client to server.</p> <pre><code>type ClientMessage struct {\n    Type     string       `json:\"type\"`\n    DocID    string       `json:\"docId,omitempty\"`\n    Revision int          `json:\"revision\"`\n    Op       ot.Operation `json:\"op,omitempty\"`\n}\n</code></pre> <p></p>"},{"location":"api/server/#type-hub","title":"type Hub","text":"<p>Hub manages document sessions and routes clients to the right session.</p> <pre><code>type Hub struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/server/#func-newhub","title":"func NewHub","text":"<pre><code>func NewHub(st store.DocumentStore, engine ot.Engine) *Hub\n</code></pre>"},{"location":"api/server/#func-hub-getsession","title":"func (*Hub) GetSession","text":"<pre><code>func (h *Hub) GetSession(docID string) *Session\n</code></pre> <p>GetSession returns the session for a document, if active.</p> <p></p>"},{"location":"api/server/#func-hub-run","title":"func (*Hub) Run","text":"<pre><code>func (h *Hub) Run()\n</code></pre> <p>Run is the hub's main loop.</p> <p></p>"},{"location":"api/server/#type-servermessage","title":"type ServerMessage","text":"<p>ServerMessage is a message from server to client.</p> <pre><code>type ServerMessage struct {\n    Type     string       `json:\"type\"`\n    DocID    string       `json:\"docId,omitempty\"`\n    Content  string       `json:\"content\"`\n    Revision int          `json:\"revision\"`\n    Op       ot.Operation `json:\"op,omitempty\"`\n    ClientID string       `json:\"clientId,omitempty\"`\n    Name     string       `json:\"name,omitempty\"`\n    Color    string       `json:\"color,omitempty\"`\n    Message  string       `json:\"message,omitempty\"`\n    Clients  []ClientInfo `json:\"clients,omitempty\"`\n}\n</code></pre> <p></p>"},{"location":"api/server/#func-servermessage-encode","title":"func (ServerMessage) Encode","text":"<pre><code>func (m ServerMessage) Encode() []byte\n</code></pre> <p>Encode serializes a ServerMessage to JSON bytes.</p> <p></p>"},{"location":"api/server/#type-session","title":"type Session","text":"<p>Session manages collaboration for a single document. All operations are serialized through a single goroutine.</p> <pre><code>type Session struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/server/#func-session-run","title":"func (*Session) Run","text":"<pre><code>func (s *Session) Run()\n</code></pre> <p>Run is the session's main loop. It serializes all operations.</p> <p>Generated by gomarkdoc</p>"},{"location":"api/store/","title":"store","text":""},{"location":"api/store/#store","title":"store","text":"<pre><code>import \"github.com/alimasry/go-collab-editor/store\"\n</code></pre>"},{"location":"api/store/#index","title":"Index","text":"<ul> <li>type CachedStore</li> <li>func NewCachedStore(backing DocumentStore, flushInterval time.Duration) *CachedStore</li> <li>func (cs *CachedStore) AppendOperation(ctx context.Context, id string, op ot.Operation, version int) error</li> <li>func (cs *CachedStore) Close()</li> <li>func (cs *CachedStore) Create(ctx context.Context, id, content string) error</li> <li>func (cs *CachedStore) Get(ctx context.Context, id string) (*DocumentInfo, error)</li> <li>func (cs *CachedStore) GetOperations(ctx context.Context, id string, fromVersion int) ([]ot.Operation, error)</li> <li>func (cs *CachedStore) List(ctx context.Context) ([]DocumentInfo, error)</li> <li>func (cs *CachedStore) UpdateContent(ctx context.Context, id, content string, version int) error</li> <li>type DocumentInfo</li> <li>type DocumentStore</li> <li>type FirestoreStore</li> <li>func NewFirestoreStore(client *firestore.Client) *FirestoreStore</li> <li>func (s *FirestoreStore) AppendOperation(ctx context.Context, id string, op ot.Operation, version int) error</li> <li>func (s *FirestoreStore) Create(ctx context.Context, id, content string) error</li> <li>func (s *FirestoreStore) Get(ctx context.Context, id string) (*DocumentInfo, error)</li> <li>func (s *FirestoreStore) GetOperations(ctx context.Context, id string, fromVersion int) ([]ot.Operation, error)</li> <li>func (s *FirestoreStore) List(ctx context.Context) ([]DocumentInfo, error)</li> <li>func (s *FirestoreStore) UpdateContent(ctx context.Context, id, content string, version int) error</li> <li>type MemoryStore</li> <li>func NewMemoryStore() *MemoryStore</li> <li>func (s *MemoryStore) AppendOperation(_ context.Context, id string, op ot.Operation, version int) error</li> <li>func (s *MemoryStore) Create(_ context.Context, id, content string) error</li> <li>func (s *MemoryStore) Get(_ context.Context, id string) (*DocumentInfo, error)</li> <li>func (s *MemoryStore) GetOperations(_ context.Context, id string, fromVersion int) ([]ot.Operation, error)</li> <li>func (s *MemoryStore) List(_ context.Context) ([]DocumentInfo, error)</li> <li>func (s *MemoryStore) UpdateContent(_ context.Context, id, content string, version int) error</li> </ul>"},{"location":"api/store/#type-cachedstore","title":"type CachedStore","text":"<p>CachedStore wraps a backing DocumentStore with an in-memory cache. All reads and writes are served from the cache. Dirty documents are flushed to the backing store periodically in the background.</p> <pre><code>type CachedStore struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/store/#func-newcachedstore","title":"func NewCachedStore","text":"<pre><code>func NewCachedStore(backing DocumentStore, flushInterval time.Duration) *CachedStore\n</code></pre> <p>NewCachedStore creates a CachedStore that caches in memory and flushes dirty documents to the backing store every flushInterval.</p> <p></p>"},{"location":"api/store/#func-cachedstore-appendoperation","title":"func (*CachedStore) AppendOperation","text":"<pre><code>func (cs *CachedStore) AppendOperation(ctx context.Context, id string, op ot.Operation, version int) error\n</code></pre>"},{"location":"api/store/#func-cachedstore-close","title":"func (*CachedStore) Close","text":"<pre><code>func (cs *CachedStore) Close()\n</code></pre> <p>Close signals the flush loop to perform a final flush and waits for it to complete.</p> <p></p>"},{"location":"api/store/#func-cachedstore-create","title":"func (*CachedStore) Create","text":"<pre><code>func (cs *CachedStore) Create(ctx context.Context, id, content string) error\n</code></pre>"},{"location":"api/store/#func-cachedstore-get","title":"func (*CachedStore) Get","text":"<pre><code>func (cs *CachedStore) Get(ctx context.Context, id string) (*DocumentInfo, error)\n</code></pre>"},{"location":"api/store/#func-cachedstore-getoperations","title":"func (*CachedStore) GetOperations","text":"<pre><code>func (cs *CachedStore) GetOperations(ctx context.Context, id string, fromVersion int) ([]ot.Operation, error)\n</code></pre>"},{"location":"api/store/#func-cachedstore-list","title":"func (*CachedStore) List","text":"<pre><code>func (cs *CachedStore) List(ctx context.Context) ([]DocumentInfo, error)\n</code></pre>"},{"location":"api/store/#func-cachedstore-updatecontent","title":"func (*CachedStore) UpdateContent","text":"<pre><code>func (cs *CachedStore) UpdateContent(ctx context.Context, id, content string, version int) error\n</code></pre>"},{"location":"api/store/#type-documentinfo","title":"type DocumentInfo","text":"<p>DocumentInfo holds document metadata and content.</p> <pre><code>type DocumentInfo struct {\n    ID        string\n    Content   string\n    Version   int\n    CreatedAt time.Time\n    UpdatedAt time.Time\n}\n</code></pre> <p></p>"},{"location":"api/store/#type-documentstore","title":"type DocumentStore","text":"<p>DocumentStore abstracts document persistence. Implementations: MemoryStore (in-memory), FirestoreStore (Google Cloud Firestore).</p> <pre><code>type DocumentStore interface {\n    Create(ctx context.Context, id, content string) error\n    Get(ctx context.Context, id string) (*DocumentInfo, error)\n    List(ctx context.Context) ([]DocumentInfo, error)\n    UpdateContent(ctx context.Context, id, content string, version int) error\n    AppendOperation(ctx context.Context, id string, op ot.Operation, version int) error\n    GetOperations(ctx context.Context, id string, fromVersion int) ([]ot.Operation, error)\n}\n</code></pre> <p></p>"},{"location":"api/store/#type-firestorestore","title":"type FirestoreStore","text":"<p>FirestoreStore is a Firestore-backed implementation of DocumentStore.</p> <pre><code>type FirestoreStore struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/store/#func-newfirestorestore","title":"func NewFirestoreStore","text":"<pre><code>func NewFirestoreStore(client *firestore.Client) *FirestoreStore\n</code></pre> <p>NewFirestoreStore creates a new FirestoreStore using the given Firestore client.</p> <p></p>"},{"location":"api/store/#func-firestorestore-appendoperation","title":"func (*FirestoreStore) AppendOperation","text":"<pre><code>func (s *FirestoreStore) AppendOperation(ctx context.Context, id string, op ot.Operation, version int) error\n</code></pre>"},{"location":"api/store/#func-firestorestore-create","title":"func (*FirestoreStore) Create","text":"<pre><code>func (s *FirestoreStore) Create(ctx context.Context, id, content string) error\n</code></pre>"},{"location":"api/store/#func-firestorestore-get","title":"func (*FirestoreStore) Get","text":"<pre><code>func (s *FirestoreStore) Get(ctx context.Context, id string) (*DocumentInfo, error)\n</code></pre>"},{"location":"api/store/#func-firestorestore-getoperations","title":"func (*FirestoreStore) GetOperations","text":"<pre><code>func (s *FirestoreStore) GetOperations(ctx context.Context, id string, fromVersion int) ([]ot.Operation, error)\n</code></pre>"},{"location":"api/store/#func-firestorestore-list","title":"func (*FirestoreStore) List","text":"<pre><code>func (s *FirestoreStore) List(ctx context.Context) ([]DocumentInfo, error)\n</code></pre>"},{"location":"api/store/#func-firestorestore-updatecontent","title":"func (*FirestoreStore) UpdateContent","text":"<pre><code>func (s *FirestoreStore) UpdateContent(ctx context.Context, id, content string, version int) error\n</code></pre>"},{"location":"api/store/#type-memorystore","title":"type MemoryStore","text":"<p>MemoryStore is an in-memory implementation of DocumentStore.</p> <pre><code>type MemoryStore struct {\n    // contains filtered or unexported fields\n}\n</code></pre> <p></p>"},{"location":"api/store/#func-newmemorystore","title":"func NewMemoryStore","text":"<pre><code>func NewMemoryStore() *MemoryStore\n</code></pre>"},{"location":"api/store/#func-memorystore-appendoperation","title":"func (*MemoryStore) AppendOperation","text":"<pre><code>func (s *MemoryStore) AppendOperation(_ context.Context, id string, op ot.Operation, version int) error\n</code></pre>"},{"location":"api/store/#func-memorystore-create","title":"func (*MemoryStore) Create","text":"<pre><code>func (s *MemoryStore) Create(_ context.Context, id, content string) error\n</code></pre>"},{"location":"api/store/#func-memorystore-get","title":"func (*MemoryStore) Get","text":"<pre><code>func (s *MemoryStore) Get(_ context.Context, id string) (*DocumentInfo, error)\n</code></pre>"},{"location":"api/store/#func-memorystore-getoperations","title":"func (*MemoryStore) GetOperations","text":"<pre><code>func (s *MemoryStore) GetOperations(_ context.Context, id string, fromVersion int) ([]ot.Operation, error)\n</code></pre>"},{"location":"api/store/#func-memorystore-list","title":"func (*MemoryStore) List","text":"<pre><code>func (s *MemoryStore) List(_ context.Context) ([]DocumentInfo, error)\n</code></pre>"},{"location":"api/store/#func-memorystore-updatecontent","title":"func (*MemoryStore) UpdateContent","text":"<pre><code>func (s *MemoryStore) UpdateContent(_ context.Context, id, content string, version int) error\n</code></pre> <p>Generated by gomarkdoc</p>"},{"location":"architecture/frontend-client/","title":"Frontend OT Client","text":"<p>The frontend (<code>static/js/main.js</code>) implements the same OT algorithms as the Go backend, plus a state machine for managing in-flight operations.</p>"},{"location":"architecture/frontend-client/#state-machine","title":"State machine","text":"<p>The client uses a 3-state machine to handle the asynchronous nature of WebSocket communication:</p> <pre><code>stateDiagram-v2\n    [*] --&gt; Synchronized\n\n    Synchronized --&gt; AwaitingAck: local edit&lt;br/&gt;(send op to server)\n    AwaitingAck --&gt; Synchronized: receive ack\n    AwaitingAck --&gt; AwaitingAckWithBuffer: local edit&lt;br/&gt;(buffer op)\n    AwaitingAckWithBuffer --&gt; AwaitingAck: receive ack&lt;br/&gt;(send buffer to server)\n    AwaitingAckWithBuffer --&gt; AwaitingAckWithBuffer: local edit&lt;br/&gt;(compose into buffer)</code></pre>"},{"location":"architecture/frontend-client/#synchronized","title":"Synchronized","text":"<p>No operations in flight. Local edits are sent immediately to the server.</p>"},{"location":"architecture/frontend-client/#awaitingack","title":"AwaitingAck","text":"<p>One operation has been sent to the server and we're waiting for acknowledgment. New local edits are stored in a buffer.</p>"},{"location":"architecture/frontend-client/#awaitingackwithbuffer","title":"AwaitingAckWithBuffer","text":"<p>An operation is in flight and the user has made additional edits. New local edits are merged into the existing buffer using <code>compose()</code>.</p> <p>When the ack arrives, the buffer becomes the new in-flight operation and is sent to the server.</p>"},{"location":"architecture/frontend-client/#handling-remote-operations","title":"Handling remote operations","text":"<p>When a remote operation arrives from the server, it must be transformed against any local pending/buffered operations:</p> State Action Synchronized Apply remote op directly AwaitingAck Transform pending against remote op, apply the transformed remote op AwaitingAckWithBuffer Transform pending, then buffer, then apply the doubly-transformed remote op"},{"location":"architecture/frontend-client/#compose","title":"Compose","text":"<p><code>compose(a, b)</code> merges two sequential operations into one. If a user types <code>\"he\"</code> then <code>\"llo\"</code>, compose combines them into a single operation that inserts <code>\"hello\"</code>. This keeps the buffer as a single operation rather than a growing list.</p> <p>The algorithm walks both operations simultaneously:</p> <ul> <li><code>a</code> deletes consume <code>a</code>'s input directly (pass through)</li> <li><code>b</code> inserts produce output directly (pass through)</li> <li>Overlapping retain/delete/insert pairs are combined by taking the minimum length chunk</li> </ul>"},{"location":"architecture/frontend-client/#codemirror-integration","title":"CodeMirror integration","text":""},{"location":"architecture/frontend-client/#local-edits-makeop","title":"Local edits (<code>makeOp</code>)","text":"<p>When CodeMirror fires a <code>change</code> event, <code>makeOp</code> converts it to an OT operation:</p> <ol> <li>Calculate <code>from</code> position (index in document)</li> <li>Build components: <code>Retain(from)</code> + <code>Delete(removedLen)</code> + <code>Insert(insertedText)</code> + <code>Retain(remaining)</code></li> </ol>"},{"location":"architecture/frontend-client/#remote-edits-applyremoteop","title":"Remote edits (<code>applyRemoteOp</code>)","text":"<p>Remote operations are applied to CodeMirror with change suppression to avoid re-sending:</p> <ol> <li>Set <code>suppressChange = true</code></li> <li>Apply the operation to get the new document string</li> <li>Transform the cursor position through the operation (<code>transformIndex</code>)</li> <li>Set the new value and restore the cursor</li> <li>Set <code>suppressChange = false</code></li> </ol>"},{"location":"architecture/frontend-client/#cursor-preservation-transformindex","title":"Cursor preservation (<code>transformIndex</code>)","text":"<p><code>transformIndex</code> walks through an operation's components and adjusts a cursor position:</p> <ul> <li>Retain: no effect (just advance)</li> <li>Insert before cursor: shift cursor right by insert length</li> <li>Delete before cursor: shift cursor left by delete length (clamped to 0)</li> </ul>"},{"location":"architecture/frontend-client/#connection-management","title":"Connection management","text":"<ul> <li>Connects to <code>ws://host/ws</code> (or <code>wss://</code> for HTTPS)</li> <li>On open: sends <code>join</code> with the document ID</li> <li>On close: auto-reconnects after 2 seconds</li> <li>Document identity is the URL hash (<code>#abc123</code>) \u2014 same URL = same document</li> <li>Hash changes trigger disconnect + reconnect to the new document</li> </ul>"},{"location":"architecture/goroutine-model/","title":"Goroutine Model","text":"<p>The server uses a hierarchy of goroutines with channel-based communication. No mutexes are needed on document state.</p>"},{"location":"architecture/goroutine-model/#goroutine-hierarchy","title":"Goroutine hierarchy","text":"<pre><code>graph TD\n    H[Hub&lt;br/&gt;1 goroutine] --&gt; S1[Session: doc1&lt;br/&gt;1 goroutine]\n    H --&gt; S2[Session: doc2&lt;br/&gt;1 goroutine]\n    S1 --&gt; C1[Client A&lt;br/&gt;ReadPump + WritePump]\n    S1 --&gt; C2[Client B&lt;br/&gt;ReadPump + WritePump]\n    S2 --&gt; C3[Client C&lt;br/&gt;ReadPump + WritePump]</code></pre>"},{"location":"architecture/goroutine-model/#hub","title":"Hub","text":"<p>The <code>Hub</code> routes clients to document sessions. It runs a single goroutine that reads from the <code>joinDoc</code> channel:</p> <pre><code>func (h *Hub) Run() {\n    for req := range h.joinDoc {\n        h.handleJoinDoc(req)\n    }\n}\n</code></pre> <p>When a join request arrives, the Hub either retrieves the existing session or creates a new one:</p> <ol> <li>Check the session map (protected by <code>sync.RWMutex</code>)</li> <li>If not found: create the document in the store, load it, create a new <code>Session</code>, start it with <code>go s.Run()</code></li> <li>Send the client to the session's <code>join</code> channel</li> </ol> <p>The <code>sync.RWMutex</code> on <code>Hub</code> only protects the session map, not document state.</p>"},{"location":"architecture/goroutine-model/#session","title":"Session","text":"<p>Each document gets its own <code>Session</code> running in a single goroutine. This is the core serialization design \u2014 all OT transforms, document mutations, and broadcasts happen sequentially:</p> <pre><code>func (s *Session) Run() {\n    for {\n        select {\n        case c := &lt;-s.join:\n            s.handleJoin(c)\n        case c := &lt;-s.leave:\n            s.handleLeave(c)\n        case om := &lt;-s.incoming:\n            s.handleOp(om)\n        case &lt;-s.stop:\n            return\n        }\n    }\n}\n</code></pre>"},{"location":"architecture/goroutine-model/#channels","title":"Channels","text":"Channel Buffer Purpose <code>join</code> 16 Client join requests <code>leave</code> 16 Client departures <code>incoming</code> 64 Operations from clients <code>stop</code> 0 Shutdown signal"},{"location":"architecture/goroutine-model/#operation-handling","title":"Operation handling","text":"<p>When a client sends an operation:</p> <ol> <li>Transform \u2014 <code>engine.TransformIncoming(op, revision, history)</code> transforms the operation against server history since the client's last known revision</li> <li>Apply \u2014 <code>doc.Apply(transformed)</code> updates the document content and increments the version</li> <li>Persist \u2014 <code>store.UpdateContent()</code> and <code>store.AppendOperation()</code> save the state</li> <li>Ack \u2014 send <code>ack</code> with new revision to the sender</li> <li>Broadcast \u2014 send the transformed <code>op</code> to all other clients in the session</li> </ol>"},{"location":"architecture/goroutine-model/#client","title":"Client","text":"<p>Each WebSocket connection is a <code>Client</code> with two goroutines:</p>"},{"location":"architecture/goroutine-model/#readpump","title":"ReadPump","text":"<p>Reads JSON messages from the WebSocket and dispatches them:</p> <ul> <li><code>join</code> messages go to <code>hub.joinDoc</code></li> <li><code>op</code> messages go to <code>session.incoming</code></li> <li>Unknown types get an error response</li> </ul> <p>Connection settings:</p> Setting Value <code>maxMsgSize</code> 64 KB <code>pongWait</code> 60 seconds"},{"location":"architecture/goroutine-model/#writepump","title":"WritePump","text":"<p>Drains the <code>send</code> channel (buffered to 256 messages) and writes to the WebSocket. Also sends periodic pings:</p> Setting Value <code>writeWait</code> 10 seconds <code>pingPeriod</code> 54 seconds (90% of pongWait) <p>If the <code>send</code> channel is full when a message arrives, the message is dropped (slow client protection).</p>"},{"location":"architecture/ot-algorithm/","title":"OT Algorithm","text":"<p>The editor uses a retain/insert/delete sequential operation model. This page explains how operations work, how concurrent edits are merged, and how the Jupiter engine ties it all together.</p>"},{"location":"architecture/ot-algorithm/#operation-model","title":"Operation model","text":"<p>An <code>Operation</code> is a list of <code>Component</code> values that walk the document left-to-right. Every component does one of three things:</p> Component Effect <code>Retain(n)</code> Keep the next <code>n</code> characters unchanged <code>Insert(s)</code> Insert string <code>s</code> at the current cursor position <code>Delete(n)</code> Remove the next <code>n</code> characters <p>An operation must account for the entire input document \u2014 the sum of <code>Retain</code> and <code>Delete</code> values must equal the document length.</p>"},{"location":"architecture/ot-algorithm/#examples","title":"Examples","text":"<p>Insert <code>\"X\"</code> at position 2 in <code>\"hello\"</code> (length 5):</p> <pre><code>[Retain(2), Insert(\"X\"), Retain(3)]\n</code></pre> <p>Result: <code>\"heXllo\"</code></p> <p>Delete 2 characters at position 1 in <code>\"hello\"</code> (length 5):</p> <pre><code>[Retain(1), Delete(2), Retain(2)]\n</code></pre> <p>Result: <code>\"hlo\"</code></p>"},{"location":"architecture/ot-algorithm/#convenience-constructors","title":"Convenience constructors","text":"<pre><code>// Insert \"world\" at position 5 in a 5-char document\nop := ot.NewInsert(5, \"world\", 5)\n// Produces: [Retain(5), Insert(\"world\")]\n\n// Delete 3 chars at position 0 in a 10-char document\nop := ot.NewDelete(0, 3, 10)\n// Produces: [Delete(3), Retain(7)]\n</code></pre>"},{"location":"architecture/ot-algorithm/#length-invariants","title":"Length invariants","text":"<p>Every operation has two length properties:</p> <ul> <li><code>BaseLen()</code> \u2014 the expected input document length (sum of <code>Retain</code> + <code>Delete</code>)</li> <li><code>TargetLen()</code> \u2014 the output document length after applying (sum of <code>Retain</code> + <code>Insert</code>)</li> </ul> <p><code>Apply</code> verifies that <code>len(doc) == op.BaseLen()</code> before executing.</p>"},{"location":"architecture/ot-algorithm/#apply","title":"Apply","text":"<p><code>Apply(doc, op)</code> walks the components left-to-right, building a result string:</p> <ul> <li>Retain: copy <code>n</code> characters from the input</li> <li>Insert: append the insert text</li> <li>Delete: skip <code>n</code> characters in the input</li> </ul>"},{"location":"architecture/ot-algorithm/#transform","title":"Transform","text":"<p><code>Transform(a, b)</code> takes two concurrent operations (both applied to the same document state) and returns <code>aPrime</code> and <code>bPrime</code> such that:</p> <pre><code>Apply(Apply(doc, a), bPrime) == Apply(Apply(doc, b), aPrime)\n</code></pre> <p>This is the convergence property \u2014 regardless of which operation is applied first, the final document state is the same.</p>"},{"location":"architecture/ot-algorithm/#algorithm","title":"Algorithm","text":"<p>The transform uses an iterator-based approach. Two iterators walk through operations <code>a</code> and <code>b</code> simultaneously:</p> <ol> <li>Both insert: operation <code>a</code> wins (tie-break rule). <code>a</code>'s insert goes into <code>aPrime</code>, and <code>bPrime</code> gets a <code>Retain</code> to skip over the inserted text.</li> <li>One inserts: the insert goes into its prime, the other gets a <code>Retain</code>.</li> <li>Both consume input: take the shorter chunk of the two:<ul> <li>Retain vs Retain: both primes retain</li> <li>Delete vs Retain: the delete goes into its prime, the other drops the component</li> <li>Delete vs Delete: both delete the same characters, nothing to emit</li> </ul> </li> </ol>"},{"location":"architecture/ot-algorithm/#tie-break-rule","title":"Tie-break rule","text":"<p>When both operations insert at the same position, operation <code>a</code> (the first argument) wins \u2014 its insert is placed first. This provides deterministic ordering for concurrent inserts at the same position.</p>"},{"location":"architecture/ot-algorithm/#compact","title":"Compact","text":"<p>After transform, <code>compact()</code> merges adjacent components of the same type. For example, <code>[Retain(2), Retain(3)]</code> becomes <code>[Retain(5)]</code>.</p>"},{"location":"architecture/ot-algorithm/#jupiter-engine","title":"Jupiter Engine","text":"<p><code>JupiterEngine</code> implements the <code>Engine</code> interface. When a client sends an operation created at revision <code>r</code>, the engine sequentially transforms it against every server operation from <code>history[r:]</code>:</p> <pre><code>func (e *JupiterEngine) TransformIncoming(op Operation, revision int, history []Operation) (Operation, error) {\n    transformed := op\n    for i := revision; i &lt; len(history); i++ {\n        transformed, _, _ = Transform(transformed, history[i])\n    }\n    return transformed, nil\n}\n</code></pre> <p>After transformation, the operation is safe to apply at the current server state.</p>"},{"location":"architecture/overview/","title":"Architecture Overview","text":""},{"location":"architecture/overview/#package-dependency-graph","title":"Package dependency graph","text":"<pre><code>graph TD\n    A[main.go] --&gt; B[server/]\n    B --&gt; C[ot/]\n    B --&gt; D[store/]\n    E[static/] -.-&gt;|served by| B</code></pre> <ul> <li><code>ot/</code> \u2014 Pure algorithm library with zero dependencies on other packages. Contains the operation model, transform function, and engine interface.</li> <li><code>server/</code> \u2014 HTTP handler, WebSocket hub, per-document sessions, and client connection management. Depends on <code>ot/</code> and <code>store/</code>.</li> <li><code>store/</code> \u2014 Document persistence abstraction. <code>MemoryStore</code> (in-memory), <code>FirestoreStore</code> (Google Cloud Firestore), and <code>CachedStore</code> (write-behind cache wrapping any <code>DocumentStore</code>) are the available implementations.</li> <li><code>static/</code> \u2014 Vanilla JS frontend with CodeMirror 5. Implements the same OT transform algorithm as the Go backend.</li> </ul>"},{"location":"architecture/overview/#data-flow","title":"Data flow","text":"<pre><code>sequenceDiagram\n    participant Client as Browser\n    participant WS as WebSocket Handler\n    participant Hub\n    participant Session\n    participant Engine as OT Engine\n    participant Store as DocumentStore\n\n    Client-&gt;&gt;WS: Connect to /ws\n    WS-&gt;&gt;WS: Upgrade to WebSocket\n    WS--&gt;&gt;Client: Connection established\n\n    Client-&gt;&gt;Hub: join {docId}\n    Hub-&gt;&gt;Store: Get or Create document\n    Hub-&gt;&gt;Session: Create session (if new)\n    Session--&gt;&gt;Client: doc {content, revision, clients}\n\n    Client-&gt;&gt;Session: op {revision, operation}\n    Session-&gt;&gt;Engine: TransformIncoming(op, revision, history)\n    Engine--&gt;&gt;Session: transformed operation\n    Session-&gt;&gt;Store: UpdateContent + AppendOperation\n    Session--&gt;&gt;Client: ack {revision}\n    Session--&gt;&gt;Client: op broadcast to other clients</code></pre>"},{"location":"architecture/overview/#key-design-decisions","title":"Key design decisions","text":"<p>Single-goroutine-per-session: Each document session runs in exactly one goroutine. All OT transforms, document mutations, and client broadcasts happen sequentially in that goroutine via channel receives. This eliminates the need for mutexes on document state and makes the concurrency model simple to reason about.</p> <p>Retain/insert/delete model: Operations are sequences of components that walk the entire document left-to-right, rather than position-based point mutations. This makes transform and compose operations well-defined and composable.</p> <p>Interface-driven extensibility: <code>ot.Engine</code> and <code>store.DocumentStore</code> are interfaces. New OT algorithms (Wave, CRDT adapters) or storage backends (Firestore, PostgreSQL) can be swapped in without changing server code.</p> <p>Write-behind caching: When using Firestore, a <code>CachedStore</code> wraps the <code>FirestoreStore</code>, serving all reads and writes from an in-memory cache. Dirty documents are flushed to Firestore periodically (default 5s) in a background goroutine, batching per-keystroke writes to reduce cost and latency. Ops are flushed before content so crash-recovery can replay ops even if the stored content is slightly stale.</p>"},{"location":"protocol/messages/","title":"Message Reference","text":"<p>All messages are JSON objects with a <code>type</code> field. This page documents every message type.</p>"},{"location":"protocol/messages/#client-to-server","title":"Client to server","text":""},{"location":"protocol/messages/#join","title":"<code>join</code>","text":"<p>Join or create a document session.</p> <pre><code>{\n  \"type\": \"join\",\n  \"docId\": \"abc123\"\n}\n</code></pre> Field Type Description <code>type</code> string Always <code>\"join\"</code> <code>docId</code> string Document identifier <p>If the document doesn't exist, the server creates it with empty content.</p>"},{"location":"protocol/messages/#op","title":"<code>op</code>","text":"<p>Send an editing operation.</p> <pre><code>{\n  \"type\": \"op\",\n  \"docId\": \"abc123\",\n  \"revision\": 5,\n  \"op\": {\n    \"ops\": [\n      {\"retain\": 3},\n      {\"insert\": \"hello\"},\n      {\"retain\": 7}\n    ]\n  }\n}\n</code></pre> Field Type Description <code>type</code> string Always <code>\"op\"</code> <code>docId</code> string Document identifier <code>revision</code> int Client's last known server revision <code>op</code> Operation The editing operation"},{"location":"protocol/messages/#server-to-client","title":"Server to client","text":""},{"location":"protocol/messages/#doc","title":"<code>doc</code>","text":"<p>Full document state, sent in response to <code>join</code>.</p> <pre><code>{\n  \"type\": \"doc\",\n  \"docId\": \"abc123\",\n  \"content\": \"hello world\",\n  \"revision\": 5,\n  \"clients\": [\n    {\"id\": \"a1b2c3d4\", \"name\": \"Blue Fox\", \"color\": \"#3498db\"},\n    {\"id\": \"e5f6g7h8\", \"name\": \"Red Owl\", \"color\": \"#e74c3c\"}\n  ]\n}\n</code></pre> Field Type Description <code>type</code> string Always <code>\"doc\"</code> <code>docId</code> string Document identifier <code>content</code> string Full document text <code>revision</code> int Current server revision <code>clients</code> ClientInfo[] List of connected users"},{"location":"protocol/messages/#ack","title":"<code>ack</code>","text":"<p>Acknowledges a successfully applied operation.</p> <pre><code>{\n  \"type\": \"ack\",\n  \"revision\": 6\n}\n</code></pre> Field Type Description <code>type</code> string Always <code>\"ack\"</code> <code>revision</code> int New server revision after applying the operation"},{"location":"protocol/messages/#op-broadcast","title":"<code>op</code> (broadcast)","text":"<p>A remote operation from another client.</p> <pre><code>{\n  \"type\": \"op\",\n  \"docId\": \"abc123\",\n  \"revision\": 6,\n  \"op\": {\n    \"ops\": [\n      {\"retain\": 5},\n      {\"delete\": 3},\n      {\"retain\": 2}\n    ]\n  },\n  \"clientId\": \"a1b2c3d4\"\n}\n</code></pre> Field Type Description <code>type</code> string Always <code>\"op\"</code> <code>docId</code> string Document identifier <code>revision</code> int Server revision after this operation <code>op</code> Operation The transformed operation <code>clientId</code> string ID of the client that authored the operation"},{"location":"protocol/messages/#join-presence","title":"<code>join</code> (presence)","text":"<p>A new user connected to the document.</p> <pre><code>{\n  \"type\": \"join\",\n  \"clientId\": \"a1b2c3d4\",\n  \"name\": \"Blue Fox\",\n  \"color\": \"#3498db\"\n}\n</code></pre> Field Type Description <code>type</code> string Always <code>\"join\"</code> <code>clientId</code> string New client's ID <code>name</code> string Display name (randomly generated) <code>color</code> string Hex color for presence indicators"},{"location":"protocol/messages/#leave","title":"<code>leave</code>","text":"<p>A user disconnected from the document.</p> <pre><code>{\n  \"type\": \"leave\",\n  \"clientId\": \"a1b2c3d4\"\n}\n</code></pre> Field Type Description <code>type</code> string Always <code>\"leave\"</code> <code>clientId</code> string Departing client's ID"},{"location":"protocol/messages/#error","title":"<code>error</code>","text":"<p>An error occurred processing a client message.</p> <pre><code>{\n  \"type\": \"error\",\n  \"message\": \"not joined to a document\"\n}\n</code></pre> Field Type Description <code>type</code> string Always <code>\"error\"</code> <code>message</code> string Human-readable error description"},{"location":"protocol/messages/#data-types","title":"Data types","text":""},{"location":"protocol/messages/#operation","title":"Operation","text":"<pre><code>{\n  \"ops\": [\n    {\"retain\": 5},\n    {\"insert\": \"hello\"},\n    {\"delete\": 3}\n  ]\n}\n</code></pre> <p>An array of components. Each component has exactly one field set:</p> Field Type Description <code>retain</code> int Number of characters to keep unchanged <code>insert</code> string Text to insert at the current position <code>delete</code> int Number of characters to remove"},{"location":"protocol/messages/#clientinfo","title":"ClientInfo","text":"<pre><code>{\n  \"id\": \"a1b2c3d4\",\n  \"name\": \"Blue Fox\",\n  \"color\": \"#3498db\"\n}\n</code></pre> Field Type Description <code>id</code> string 8-character alphanumeric client ID <code>name</code> string Random name (adjective + animal, e.g. \"Blue Fox\") <code>color</code> string Hex color from a predefined palette"},{"location":"protocol/websocket/","title":"WebSocket Protocol","text":"<p>All real-time communication uses a single WebSocket endpoint with JSON messages.</p>"},{"location":"protocol/websocket/#endpoint","title":"Endpoint","text":"<pre><code>ws://host/ws      (plain)\nwss://host/ws     (TLS)\n</code></pre> <p>The server accepts any origin (<code>CheckOrigin</code> always returns <code>true</code>).</p>"},{"location":"protocol/websocket/#connection-lifecycle","title":"Connection lifecycle","text":"<pre><code>sequenceDiagram\n    participant C as Client\n    participant S as Server\n\n    C-&gt;&gt;S: WebSocket connect /ws\n    S--&gt;&gt;C: Connection upgraded\n\n    C-&gt;&gt;S: {\"type\":\"join\",\"docId\":\"abc123\"}\n    S--&gt;&gt;C: {\"type\":\"doc\",\"docId\":\"abc123\",\"content\":\"...\",\"revision\":5,\"clients\":[...]}\n\n    Note over C,S: Collaboration session active\n\n    C-&gt;&gt;S: {\"type\":\"op\",\"docId\":\"abc123\",\"revision\":5,\"op\":{...}}\n    S--&gt;&gt;C: {\"type\":\"ack\",\"revision\":6}\n    S--&gt;&gt;C: {\"type\":\"op\",\"docId\":\"abc123\",\"revision\":6,\"op\":{...},\"clientId\":\"xyz\"}\n    Note right of C: Broadcast to other clients\n\n    Note over C,S: Another user joins\n    S--&gt;&gt;C: {\"type\":\"join\",\"clientId\":\"def456\",\"name\":\"Blue Fox\",\"color\":\"#3498db\"}\n\n    Note over C,S: A user leaves\n    S--&gt;&gt;C: {\"type\":\"leave\",\"clientId\":\"def456\"}\n\n    Note over C,S: Error handling\n    S--&gt;&gt;C: {\"type\":\"error\",\"message\":\"transform error: ...\"}</code></pre>"},{"location":"protocol/websocket/#flow","title":"Flow","text":"<ol> <li>Connect \u2014 client opens a WebSocket connection to <code>/ws</code></li> <li>Join \u2014 client sends a <code>join</code> message with the target <code>docId</code></li> <li>Receive state \u2014 server responds with a <code>doc</code> message containing the full document content, current revision, and list of connected clients</li> <li>Edit \u2014 client sends <code>op</code> messages with their last known <code>revision</code> and the operation</li> <li>Ack \u2014 server transforms the operation against any concurrent changes, applies it, and sends an <code>ack</code> with the new revision</li> <li>Broadcast \u2014 server sends the transformed operation to all other clients in the session</li> <li>Presence \u2014 <code>join</code> and <code>leave</code> messages are broadcast when users connect/disconnect</li> </ol>"},{"location":"protocol/websocket/#error-handling","title":"Error handling","text":"<p>The server sends <code>error</code> messages in these cases:</p> <ul> <li>Invalid message format \u2014 JSON parse failure</li> <li>Not joined \u2014 client sends an <code>op</code> before joining a document</li> <li>Unknown message type \u2014 unrecognized <code>type</code> field</li> <li>Transform error \u2014 OT transform fails (e.g. base length mismatch)</li> <li>Apply error \u2014 operation cannot be applied to current document state</li> </ul>"},{"location":"protocol/websocket/#connection-parameters","title":"Connection parameters","text":"Parameter Value Max message size 64 KB Ping interval 54 seconds Pong timeout 60 seconds Write timeout 10 seconds <p>The server sends WebSocket pings every 54 seconds. If the client doesn't respond with a pong within 60 seconds, the connection is closed.</p>"}]}